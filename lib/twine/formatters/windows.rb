require "rexml/document"

module Twine
  module Formatters
    class Windows < Abstract
      include Twine::Placeholders

      def format_name
        'windows'
      end

      def extension
        '.resw'
      end

      def match_locale(item)
        /^([a-z]{2})(-[a-z]{2})?$/i.match(item)
      end

      def can_handle_directory?(path)
        Dir.entries(path).any? { |item| match_locale item }
      end

      def default_file_name
        return 'Resources.resw'
      end

      def determine_language_given_path(path)
        path.split(File::SEPARATOR).each do |segment|
          match = match_locale segment
          return match[1] if match
        end
      end

      def output_path_for_language(lang)
        lang
      end

      def set_translation_for_key(key, lang, value)
        value = CGI.unescapeHTML(value)
        value = convert_string_placeholder_from_printf_to_twine(value)
        super(key, lang, value)
      end

      def read_file(io, lang)
        doc = REXML::Document.new io

        doc.elements.each("root/data") do |element| 
          key = element.attributes["name"]
          value_element = element.elements["value"]
          set_translation_for_key(key, lang, value_element.text) if value_element

          comment_element = element.elements["comment"]
          set_comment_for_key(key, comment_element.text) if comment_element
        end
      end

      def format_header(lang)
        "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!-- Windows Strings File -->\n<!-- Generated by Twine #{Twine::VERSION} -->\n<!-- Language: #{lang} -->"
      end

      def format_sections(twine_file, lang)
        result = "<root>\n"
        result += SCHEMA
        result += super + "\n"
        result += "</root>\n"
      end

      def format_section_header(section)
        "\t<!-- #{section.name} -->"
      end

      def format_definition(row, lang)
        result = "\t<data name=\"#{format_key(row.key.dup)}\" xml:space=\"preserve\">\n"
        result += "\t\t<value>#{format_value(row.translations[lang].dup)}</value>\n"
        comment = format_comment(row, lang)
        result += comment if comment
        result += "\t</data>"
      end

      def format_value(value)
        value = CGI.escapeHTML(value)
        convert_string_placeholder_from_twine_to_printf(value)
      end

      def format_comment(row, lang)
      	"\t\t<comment>#{row.comment}</comment>\n" if row.comment
      end
    end
  end
end

Twine::Formatters.formatters << Twine::Formatters::Windows.new

module Twine
  module Formatters
    class Windows
        SCHEMA = <<-SCHEMA
	<xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
		<xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
		<xsd:element name="root" msdata:IsDataSet="true">
			<xsd:complexType>
				<xsd:choice maxOccurs="unbounded">
					<xsd:element name="metadata">
						<xsd:complexType>
							<xsd:sequence>
								<xsd:element name="value" type="xsd:string" minOccurs="0" />
							</xsd:sequence>
							<xsd:attribute name="name" use="required" type="xsd:string" />
							<xsd:attribute name="type" type="xsd:string" />
							<xsd:attribute name="mimetype" type="xsd:string" />
							<xsd:attribute ref="xml:space" />
						</xsd:complexType>
					</xsd:element>
					<xsd:element name="assembly">
						<xsd:complexType>
							<xsd:attribute name="alias" type="xsd:string" />
							<xsd:attribute name="name" type="xsd:string" />
						</xsd:complexType>
					</xsd:element>
					<xsd:element name="data">
						<xsd:complexType>
							<xsd:sequence>
								<xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
								<xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
							</xsd:sequence>
							<xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
							<xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
							<xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
							<xsd:attribute ref="xml:space" />
						</xsd:complexType>
					</xsd:element>
					<xsd:element name="resheader">
						<xsd:complexType>
							<xsd:sequence>
								<xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
							</xsd:sequence>
							<xsd:attribute name="name" type="xsd:string" use="required" />
						</xsd:complexType>
					</xsd:element>
				</xsd:choice>
			</xsd:complexType>
		</xsd:element>
	</xsd:schema>
	<resheader name="resmimetype">
		<value>text/microsoft-resx</value>
	</resheader>
	<resheader name="version">
		<value>2.0</value>
	</resheader>
	<resheader name="reader">
		<value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
	</resheader>
	<resheader name="writer">
		<value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
	</resheader>
SCHEMA
    end
  end
end
