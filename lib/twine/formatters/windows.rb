require "rexml/document"

module Twine
  module Formatters
    class Windows < Abstract
        SCHEMA = <<-SCHEMA
	<xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
		<xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
		<xsd:element name="root" msdata:IsDataSet="true">
			<xsd:complexType>
				<xsd:choice maxOccurs="unbounded">
					<xsd:element name="metadata">
						<xsd:complexType>
							<xsd:sequence>
								<xsd:element name="value" type="xsd:string" minOccurs="0" />
							</xsd:sequence>
							<xsd:attribute name="name" use="required" type="xsd:string" />
							<xsd:attribute name="type" type="xsd:string" />
							<xsd:attribute name="mimetype" type="xsd:string" />
							<xsd:attribute ref="xml:space" />
						</xsd:complexType>
					</xsd:element>
					<xsd:element name="assembly">
						<xsd:complexType>
							<xsd:attribute name="alias" type="xsd:string" />
							<xsd:attribute name="name" type="xsd:string" />
						</xsd:complexType>
					</xsd:element>
					<xsd:element name="data">
						<xsd:complexType>
							<xsd:sequence>
								<xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
								<xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
							</xsd:sequence>
							<xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
							<xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
							<xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
							<xsd:attribute ref="xml:space" />
						</xsd:complexType>
					</xsd:element>
					<xsd:element name="resheader">
						<xsd:complexType>
							<xsd:sequence>
								<xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
							</xsd:sequence>
							<xsd:attribute name="name" type="xsd:string" use="required" />
						</xsd:complexType>
					</xsd:element>
				</xsd:choice>
			</xsd:complexType>
		</xsd:element>
	</xsd:schema>
	<resheader name="resmimetype">
		<value>text/microsoft-resx</value>
	</resheader>
	<resheader name="version">
		<value>2.0</value>
	</resheader>
	<resheader name="reader">
		<value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
	</resheader>
	<resheader name="writer">
		<value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
	</resheader>
SCHEMA

      def format_name
        'windows'
      end

      def extension
        '.resx'
      end

      def can_handle_directory?(path)
        false # TODO: implement
      end

      def default_file_name
        return 'Localization.resx'	# TODO: double check
      end

      def determine_language_given_path(path)
        return nil	# TODO: implement
      end

      def output_path_for_language(lang)
        lang	# TODO: double check
      end

      def read_file(path, lang)
        doc = REXML::Document.new File.new(path)

        doc.elements.each("root/data") do |element| 
          key = element.attributes["name"]
          value_element = element.elements["value"]
          set_translation_for_key(key, lang, value_element.text) if value_element

          comment_element = element.elements["comment"]
          set_comment_for_key(key, comment_element.text) if comment_element
        end
      end

      # TODO: value escaping

      def format_header(lang)
        "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!-- Windows Strings File -->\n<!-- Generated by Twine #{Twine::VERSION} -->\n<!-- Language: #{lang} -->"
      end

      def format_sections(strings, lang)
        "<root>\n" + SCHEMA + super + "\n</root>"
      end

      def format_section_header(section)
        "\t<!-- #{section.name} -->"
      end

      def format_row(row, lang)
        result = "\t<data name=\"#{format_key(row.key.dup)}\" xml:space=\"preserve\">\n"
        result += "\t\t<value>#{format_value(row.translations[lang].dup)}</value>\n"
        comment = format_comment(row, lang)
        result += comment if comment
        result += "\t</data>"
      end

      def format_comment(row, lang)
      	"\t\t<comment>#{row.comment}</comment>\n" if row.comment
      end
    end
  end
end

Twine::Formatters.formatters << Twine::Formatters::Windows.new
